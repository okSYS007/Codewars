# Разработчики выстроились в очередь к кофемашине, но она сломалась! 
# К тому времени, как они добрались до запасной, они уже не помнили, 
# где кто стоял в очереди. Они хотят восстановить первоначальный порядок. 
# Первым был руководитель группы, Кэррол. Все остальные помнят, 
# сколько людей стояло между ними и Кэрролом. Можете ли вы помочь 
# им восстановить первоначальный порядок?

# Входные данные: список или массив n неотрицательных целых чисел. 
# Element i— это количество людей, которых человек i помнит в промежутке между собой и Кэррол.

# Вывод: Список или массив nнеотрицательных целых чисел, 
# представляющих исходный порядок. Поскольку Кэррол стоит первой, 
# нет необходимости включать её в вывод.

# Пример: Предположим, что на входе указано следующее: [1, 2, 0].
# Это означает, что между человеком 1 и Кэррол был один человек, 
# между человеком 2 и Кэррол — два человека, и между человеком 3
# и Кэррол — ни одного человека. Следовательно, исходный порядок, 
# за исключением Кэррол, должен был быть таким:[3, 1, 2].

# Примечание: Поскольку память ненадежна, люди могут неправильно 
# вспомнить количество людей между ними и Кэрролом. В этом случае 
# решения может не быть, поэтому вернитесь назад.[ ].

# Пример: Предположим, что на входе находится [1, 0, 1]....
# Очевидно, что не может быть так, чтобы между человеком 1 и человеком 3 
# и Кэррол находился только один человек.

# Ограничения:1 ≤ n ≤ 100.

def find_lineup(distances):
    n = len(distances)
    pos = [d + 1 for d in distances]
    if len(set(pos)) != n or any(p < 1 or p > n for p in pos):
        return []
    people = list(range(1, n+1))
    sorted_people = [p for _, p in sorted(zip(pos, people))]
    return sorted_people

print(find_lineup([1, 2, 0])) #[3, 1, 2]
print(find_lineup([1, 4, 2, 6, 8, 0, 5, 7, 3])) #[6, 1, 3, 9, 2, 7, 4, 8, 5]
print(find_lineup([0]))# [1]